# CVE-2018-1100

##### Description
**zsh** has a potential buffer overflow on utils.c:checkmailpath() function

  - Impact: Low
    - low impact since **zsh** is not a primary shell of the operating system. 

##### How works?
A local, unprivileged user can create a specially crafted message file, which, if used to set a custom 'you have new
mail' message, leads to code execution in the context of the user who receives the message. If the user affected is privileged, this leads to privilege escalation.

Since checkmailpath() function doesn't verify the length of buffer, we can send more data to these buffer, and override the memory with exploit data. Buffers are areas of memory set aside to hold datas, often while moving it from one section of a program to another, or between programs. 

Buffer overflows can often be triggered by malformed inputs; if one assumes all inputs will be smaller than a certain size and the buffer is created to be that size, then an anomalous transaction that produces more data could cause it to write past the end of the buffer. If this overwrites adjacent data or executable code, this may result in erratic program behavior, including memory access errors, incorrect results, and crashes.

##### Where is the flaw?
On checkmailpath() function, line 1667 (sprintf..):
```c
if (lock) {
		char *fn;

		pushheap();
		l = newlinklist();
		while ((fn = zreaddir(lock, 1)) && !errflag) {
		    if (u)
			sprintf(buf, "%s/%s?%s", *s, fn, u);
		    else
			sprintf(buf, "%s/%s", *s, fn);
		    addlinknode(l, dupstring(buf));
		    ct++;
		}
		closedir(lock);
		ap = arr = (char **) zhalloc(ct * sizeof(char *));
		while ((*ap++ = (char *)ugetnode(l)));
		checkmailpath(arr);
		popheap();
	    }
```

##### Why these occour?
**sprintf** takes no argument specifying the maximum number of bytes to write; it simply takes a destination buffer, a format string, and arguments.

*Therefore, it may write more bytes than your buffer has space for, and in so doing write arbitrary code.* 

**sprintf** receceive a maximum number of characters, **without** the end of null character, here's is the main problem on these case

Instead of show "you have new mail" message, for example, the attacker can produce a message with several data and inject that, to override the memory from other application or just cause Error on zsh, enabling an DoS attack.
##### How to fix?
fix on mainstream code: https://www.zsh.org/mla/workers/2018/msg00411.html
```c
		while ((fn = zreaddir(lock, 1)) && !errflag) {
		    if (u)
			    buflen = snprintf(buf, sizeof(buf), "%s/%s?%s", *s, fn, u);
		    else
			    buflen = snprintf(buf, sizeof(buf), "%s/%s", *s, fn);
		    if (buflen < 0 || buflen >= (int)sizeof(buf))
			    continue;
		    addlinknode(l, dupstring(buf));
```
Using `snprintf`, with the addition of the `n` argument, which indicates the *maximum number of characters (including at the end of null character)*  to be written to buffer. After that, verify the bondary of these buffer **before** to add the node.

Research from:
- https://www.zsh.org/mla/workers/2018/msg00411.html
- https://www.cvedetails.com/cve/CVE-2018-1100/
- https://bugzilla.redhat.com/show_bug.cgi?id=1563395
- https://access.redhat.com/security/cve/cve-2018-1100
